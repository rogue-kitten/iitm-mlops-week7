name: Week 7 Stress Test

on:
  push:
    branches:
      - main # Or 'main', or whichever branch you prefer
  workflow_dispatch:

env:
  GCP_PROJECT_ID: 'mythic-fulcrum-474215-i9'
  GKE_CLUSTER: 'demo-log-ml-cluster'
  GKE_ZONE: 'us-central1-a'

  GAR_LOCATION: 'us-central1'
  GAR_REPOSITORY: 'my-repo'

  APP_NAME: 'iris-classifier'
  SERVICE_NAME: 'iris-classifier-svc'
  HPA_NAME: 'iris-classifier-hpa'

jobs:
  build-deploy-and-test:
    name: Build, Deploy, and Stress Test
    runs-on: ubuntu-latest

    # Add permissions for GKE auth
    permissions:
      contents: 'read'
      id-token: 'write'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # 1. Authenticate to Google Cloud
      - name: Authenticate to Google Cloud
        id: auth
        uses: 'google-github-actions/auth@v2'
        with:
          credentials_json: '${{ secrets.GCP_SA_KEY }}'

      # 2. Configure Docker for Artifact Registry
      - name: Configure Docker
        run: gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev

      # 3. Build and Push Docker image
      - name: Build and Push Docker image
        run: |
          IMAGE_TAG="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.APP_NAME }}:${{ github.sha }}"

          docker build -t $IMAGE_TAG .
          docker push $IMAGE_TAG

          # Make the image tag available to subsequent steps
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      # 4. Set up GKE credentials
      - name: Set up GKE credentials
        uses: 'google-github-actions/get-gke-credentials@v2'
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}

      # 5. Deploy to Google Kubernetes Engine
      - name: Deploy to GKE
        run: |
          echo "Deploying image ${{ env.IMAGE_TAG }} to GKE cluster..."

          # Use sed to replace the placeholder image in the deployment manifest
          # This is safer than your "image:.*" as it targets the specific placeholder
          sed -i "s|image: YOUR_IMAGE_PLACEHOLDER|image: ${{ env.IMAGE_TAG }}|g" k8s/deployment.yml

          # --- CRITICAL FIX ---
          # Apply ALL manifests in the k8s directory
          # This creates the Deployment, Service, and HPA
          kubectl apply -f k8s/

          # Wait for the deployment rollout to complete
          # This now uses the correct APP_NAME
          kubectl rollout status deployment/${{ env.APP_NAME }} --timeout=2m
          echo "Deployment successful!"

      # 6. Get Service External IP
      - name: Get Service External IP
        id: get_ip
        run: |
          echo "Waiting for external IP..."
          EXTERNAL_IP=""
          while [ -z $EXTERNAL_IP ]; do
            # This now uses the correct SERVICE_NAME
            EXTERNAL_IP=$(kubectl get service ${{ env.SERVICE_NAME }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            [ -z "$EXTERNAL_IP" ] && echo "Waiting 10s for IP..." && sleep 10
          done
          echo "Obtained external IP: $EXTERNAL_IP"
          echo "SERVICE_URL=http://$EXTERNAL_IP" | tee -a $GITHUB_ENV
          echo "IP=$EXTERNAL_IP" >> $GITHUB_OUTPUT

      # 7. Install wrk for stress testing
      - name: Install wrk
        run: |
          sudo apt-get update
          sudo apt-get install -y wrk

      # 8. Run Test 1 (Autoscaling)
      - name: Run Test 1 (Autoscaling)
        run: |
          echo "--- Starting autoscaling test (60 seconds) ---"
          echo "--- This test uses 1000 concurrent connections ---"

          wrk -t4 -c1000 -d60s "${{ env.SERVICE_URL }}/predict/" -s ./wrk_script.lua &
          WRK_PID=$!

          # Observe the HPA and pod count while wrk is running
          echo "--- Observing HPA and Pods (checking every 10s for 60s) ---"
          for i in {1..6}; do
            echo "--- Check $i ---"
            kubectl get hpa,pods -o wide
            sleep 10
          done

          wait $WRK_PID # Wait for wrk to finish
          echo "--- Autoscaling test complete. Final pod count: ---"
          kubectl get pods

      # 9. Run Test 2 (Bottleneck)
      - name: Run Test 2 (Bottleneck)
        run: |
          echo "--- Preparing for bottleneck test ---"
          echo "--- Restricting max pods to 1 ---"
          # This now uses the correct HPA_NAME
          kubectl patch hpa ${{ env.HPA_NAME }} --patch '{"spec":{"maxReplicas":1}}'

          echo "Waiting 30s for cluster to scale down..."
          sleep 30

          echo "--- Pod count before bottleneck test: ---"
          kubectl get pods

          echo "--- Running bottleneck test 1 (1000 concurrent connections) ---"
          wrk -t8 -c1000 -d30s "${{ env.SERVICE_URL }}/predict/" -s ./wrk_script.lua

          echo "--- Running bottleneck test 2 (2000 concurrent connections) ---"
          wrk -t8 -c2000 -d30s "${{ env.SERVICE_URL }}/predict/" -s ./wrk_script.lua

          echo "--- Re-enabling HPA (cleanup) ---"
          kubectl patch hpa ${{ env.HPA_NAME }} --patch '{"spec":{"maxReplicas":3}}'

      # 10. Cleanup K8s resources
      - name: Cleanup K8s resources
        if: always() # This step runs even if previous steps fail
        run: |
          echo "Cleaning up Kubernetes resources..."
          kubectl delete -f k8s/
